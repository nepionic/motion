<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.13">
  <POU Name="Test" Id="{2e61a8d4-f677-443a-9a2d-e2cd0bfcaaea}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM Test
VAR
	axis1 : Mc2Axis;
	axis2 : Mc2Axis;
	
	busy : BOOL;
	active : BOOL;
	done : BOOL;
	aborted : BOOL;
	error : BOOL;
	error_id : UDINT;
	
	enable: BOOL;
	disable: BOOL;
	reset: BOOL;
	halt: BOOL;
	stop: BOOL;

	jog_forward : BOOL;
	jog_backwards : BOOL;
	
	start_move1 : BOOL;
	start_move2 : BOOL;
	
	start_homing : BOOL;
	
	gear_in : BOOL;
	gear_in_numerator : LREAL := 1;
	gear_in_denominator : UINT := 1;
	
	gear_out : BOOL;
	
	move1_command : MotionCommand;
	move2_command : MotionCommand;
	halt_command : MotionCommand;
	stop_command : MotionCommand;
	gear_in_command : AsyncCommand;
	gear_out_command : AsyncCommand;
	
	move_builder : DefaultMotionBuilder;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[axis1.CyclicCall();
axis2.CyclicCall();

error := axis1.IsErrored;
error_id := axis1.ErrorId;

IF enable THEN
	enable := FALSE;
	//axis1.Enable(AxisBufferMode.Buffered);
	axis1.Enable();
	axis1.EnablePositive();
	axis1.EnableNegative();
	axis2.Enable();
	axis2.EnablePositive();
	axis2.EnableNegative();
END_IF

IF disable THEN
	disable := FALSE;
	axis1.Disable();
END_IF

IF reset THEN
	reset := FALSE;
	axis1.Reset();
	axis2.Reset();
END_IF

IF halt THEN
	halt := FALSE;
	IF halt_command = 0 THEN
		halt_command := move_builder
			.Reset()
			.BuildHaltCommand(axis1);
	END_IF
	halt_command.Execute();
END_IF

IF stop THEN
	stop := FALSE;
	IF stop_command = 0 THEN
		stop_command := move_builder
			.Reset()
			.BuildStopCommand(axis1);
	END_IF
	stop_command.Execute();
END_IF

IF jog_forward THEN
	//axis1.JogForward(100);
ELSIF jog_backwards THEN
	//axis1.JogBackwards(100);
ELSE
	// Don't like this, since jogging now acts like MC_MoveVelocity
	// although I guess that is what it is exactly
	//axis1.StopJogging();
END_IF

IF start_homing THEN
	start_homing := FALSE;
	(*axis1.HomingBuilder()
		.Position(homePosition)
		.BuildDirectHomingCommand()
		.Execute(homingFeedback)
		.ThenRelease();*)
	(*command := axis1.HomingBuilder()
		.Position(homePosition)
		.Cam(homeCam)
		.ReferenceMode(EncoderReferenceMode.PLCCam)
		.BuildDefaultHomingCommand();*)
END_IF

(*IF setPositionAbsolute THEN
	setPositionAbsolute := FALSE;
	axis1.SetPositionAbsolute(setPositionValue);
END_IF*)

(*IF setPositionRelative THEN
	setPositionRelative := FALSE;
	axis1.SetPositionRelative(setPositionValue);
END_IF*)

IF start_move1 THEN
	start_move1 := FALSE;
	IF move1_command = 0 THEN
		move1_command := move_builder
			.Reset()
			.Position(1000)
			.Velocity(101)
			.BufferMode(MotionBufferMode.Buffered)
			.BuildMoveAbsoluteCommand(axis1);
	END_IF
	move1_command.Execute();
END_IF

IF start_move2 THEN
	start_move2 := FALSE;
	IF move2_command = 0 THEN
		move2_command := move_builder
			.Reset()
			.Distance(1000)
			.Velocity(100)
			.BuildMoveRelativeCommand(axis1);
	END_IF
	move2_command.Execute();
END_IF

IF gear_in THEN
	gear_in := FALSE;
	IF gear_in_command = 0 THEN
		gear_in_command := move_builder
			.Numerator(gear_in_numerator)
			.Denominator(gear_in_denominator)
			.BuildGearInCommand(axis1, axis2);
	END_IF
	gear_in_command.Execute();
END_IF

IF gear_out THEN
	gear_out := FALSE;
	IF gear_out_command = 0 THEN
		gear_out_command := move_builder
			.BuildGearOutCommand(axis2);
	END_IF
	gear_out_command.Execute();
END_IF

IF move1_command <> 0 THEN
	move1_command.CyclicCall();

	busy := move1_command.Busy;
	active := move1_command.Active;
	done := move1_command.Done;
	aborted := move1_command.Aborted;
	error := move1_command.Error;
	error_id := move1_command.ErrorId;
END_IF

IF move2_command <> 0 THEN
	move2_command.CyclicCall();
END_IF

IF halt_command <> 0 THEN
	halt_command.CyclicCall();
END_IF

IF stop_command <> 0 THEN
	stop_command.CyclicCall();
END_IF

IF gear_in_command <> 0 THEN
	gear_in_command.CyclicCall();
END_IF

IF gear_out_command <> 0 THEN
	gear_out_command.CyclicCall();
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>